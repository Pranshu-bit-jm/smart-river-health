<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Water Health & Index — Home (Camera pH v3)</title>
<meta name="description" content="Accurate camera-based pH detection and Water Health Index. Capture a strip, calibrate, and save reliable readings." />
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#0077b6; --bg2:#00b4d8; --card:#ffffff; --muted:#103238;
    --good:#2e7d32; --warn:#f9a825; --bad:#c62828; --radius:12px; --maxw:1100px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:"Poppins",system-ui,Arial,sans-serif;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--muted);-webkit-font-smoothing:antialiased}
  header{max-width:var(--maxw);margin:18px auto;padding:18px;display:flex;align-items:center;justify-content:space-between;color:white}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--bg2),var(--bg1));display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;font-size:18px;box-shadow:0 12px 40px rgba(0,0,0,0.18)}
  nav.site-nav{display:flex;gap:10px;align-items:center}
  nav.site-nav a{color:white;text-decoration:none;padding:8px 12px;border-radius:10px;font-weight:600}
  .page{max-width:var(--maxw);margin:22px auto;padding:0 18px}
  .layout{display:grid;grid-template-columns:1fr 360px;gap:18px}
  @media(max-width:1000px){.layout{grid-template-columns:1fr}}
  .card{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 12px 40px rgba(2,60,80,0.08)}
  .hero{background:linear-gradient(135deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));border-radius:14px;padding:18px;box-shadow:0 18px 40px rgba(2,60,80,0.08);display:flex;gap:16px;align-items:center}
  h1{margin:0;font-size:1.4rem;color:#022f33}
  .lead{color:#0b4f57}
  label{display:block;margin-top:10px;font-weight:700;color:var(--muted)}
  input[type=number], select, textarea{width:100%;padding:10px;margin-top:6px;border-radius:10px;border:1px solid #eef9ff;font-size:15px}
  .btn{background:linear-gradient(90deg,var(--bg1),var(--bg2));color:white;border:none;padding:10px 14px;border-radius:10px;font-weight:800;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(2,60,80,0.06);color:var(--muted)}
  #video{width:100%;border-radius:8px;background:#000}
  .camera-box{position:relative;border-radius:10px;overflow:hidden}
  .overlay-box{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:120px;height:48px;border:2px dashed rgba(255,255,255,0.9);border-radius:6px;pointer-events:none;box-shadow:0 6px 18px rgba(0,0,0,0.15)}
  .small{font-size:0.92rem;color:var(--muted)}
  .result-large{display:flex;gap:12px;align-items:center;padding:12px;border-radius:10px}
  .bubble{width:110px;height:110px;border-radius:999px;display:flex;align-items:center;justify-content:center;font-weight:900;color:white;font-size:1.25rem}
  .status-good{background:linear-gradient(135deg,#2e7d32,#66bb6a)}
  .status-warn{background:linear-gradient(135deg,#f9a825,#ffd54f);color:#111}
  .status-bad{background:linear-gradient(135deg,#c62828,#ff8a80)}
  .muted{color:var(--muted)}
  .kpi{font-weight:900;font-size:1.05rem}
  .advice{margin-top:10px;padding:12px;border-radius:10px;background:linear-gradient(90deg,#f6fffc,#f0f9ff);color:var(--muted)}
  footer{max-width:var(--maxw);margin:18px auto;padding:12px;color:white;text-align:center}
  .hint{font-size:0.9rem;color:#0b5962}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.06);font-weight:800}
  .cal-row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .hidden{display:none}
  .warnbox{background:#fff4e6;padding:10px;border-radius:8px;border-left:4px solid #ff8a00;margin-top:10px}
</style>
</head>
<body>

<header>
  <div class="brand">
    <div class="logo">WH</div>
    <div>
      <div style="font-weight:800;color:white">Water Health & Index</div>
      <div style="font-size:12px;color:rgba(255,255,255,0.95)">Accurate Camera pH Capture — Snapshot + Lab-grade color matching</div>
    </div>
  </div>
  <nav class="site-nav">
    <a href="index.html" style="text-decoration:underline">Home</a>
    <a href="map.html">Map</a>
    <a href="phchart.html">pH Chart</a>
    <a href="phcare.html">pH Care</a>
    <a href="details.html">Details</a>
  </nav>
</header>

<main class="page">
  <div class="hero card">
    <div style="flex:1">
      <h1>Camera pH Reader — snapshot accuracy mode</h1>
      <p class="lead">Hover the pH strip into the overlay, then press <strong>Capture</strong>. For best results: neutral white light, steady hand, and capture a white reference once per session (white card or paper).</p>

      <div style="margin-top:10px" class="controls">
        <button id="openCamBtn" class="btn">Open Camera</button>
        <button id="captureBtn" class="btn ghost" disabled>Capture</button>
        <button id="avgCaptureBtn" class="btn ghost" disabled>Average 5 captures</button>
        <button id="whiteBtn" class="btn ghost" disabled>Capture White (Balance)</button>
        <button id="closeCamBtn" class="btn ghost" style="display:none">Close Camera</button>
      </div>

      <div style="margin-top:10px" class="cal-row">
        <div class="small">Calibration:</div>
        <button id="addCalBtn" class="btn ghost" disabled>Add calibration point</button>
        <button id="resetCalBtn" class="btn ghost" disabled>Reset calibration</button>
        <div id="calStatus" style="margin-left:auto" class="small">Calibration: <span id="calCount">0</span> points</div>
      </div>

      <div id="cameraArea" style="margin-top:12px;display:none">
        <div class="card camera-box">
          <video id="video" autoplay playsinline></video>
          <div class="overlay-box" title="Place the center of the strip inside this box"></div>
        </div>
        <canvas id="snapCanvas" width="1280" height="720" style="display:none"></canvas>
        <canvas id="workCanvas" width="640" height="360" style="display:none"></canvas>
        <div class="small hint">Tip: capture white reference right after opening the camera to improve accuracy.</div>
      </div>
    </div>

    <div style="width:360px">
      <div class="card">
        <h3 style="margin:0 0 8px 0">Manual inputs</h3>
        <label>pH (manual override)</label>
        <input id="manualPH" type="number" step="0.01" min="0" max="14" placeholder="Leave empty to use camera result">

        <label>Temperature (°C)</label>
        <input id="tempInput" type="number" step="0.1" placeholder="e.g., 25">

        <label>Turbidity</label>
        <select id="turbiditySelect">
          <option value="">Choose turbidity</option>
          <option value="low">Low — Clear</option>
          <option value="medium">Medium — Cloudy</option>
          <option value="high">High — Muddy</option>
        </select>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="analyzeBtn" class="btn">Analyze Reading</button>
          <button id="saveBtn" class="btn ghost" disabled>Save Reading</button>
        </div>

        <div id="captureInfo" style="margin-top:12px" class="small muted">No capture yet.</div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0 0 8px 0">Result</h3>
        <div id="resultBlock" class="hidden">
          <div class="result-large">
            <div id="scoreBubble" class="bubble status-good">--</div>
            <div style="flex:1">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div><div class="kpi" id="indexVal">-- / 100</div><div class="small" id="indexText">—</div></div>
                <div style="text-align:right"><div class="small">pH</div><div style="font-weight:900" id="detectedPH">--</div></div>
              </div>

              <div class="advice" id="adviceShort">Advice will appear here.</div>
              <div style="margin-top:10px"><small class="muted">Confidence: <span id="confVal">--</span></small></div>
            </div>
          </div>

          <div style="margin-top:12px">
            <details>
              <summary style="font-weight:800">More details</summary>
              <div style="margin-top:8px">
                <div class="small"><strong>Subscores</strong></div>
                <div class="small" id="subscores">pH score — temp — turbidity</div>
                <div style="margin-top:8px" class="small"><strong>Captured RGB (avg)</strong> <span id="rgbVal">—</span></div>
                <div style="margin-top:6px" class="small"><strong>Calibrated?</strong> <span id="isCalibrated">—</span></div>
              </div>
            </details>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h4 style="margin:0 0 8px 0">Safety & notes</h4>
        <div class="small">If confidence is low (<0.5) or result is extreme (pH &lt;4 or &gt;11) — retest, calibrate, or send sample to lab. Always avoid direct exposure for extreme readings.</div>
        <div id="safetyWarn" class="warnbox hidden"></div>
      </div>

    </div>
  </div>

  <div style="margin-top:18px" class="layout">
    <section>
      <div class="card">
        <h2 style="margin-top:0">How the camera pH detection works (brief)</h2>
        <p class="muted">This page captures the strip color in the overlay, applies white-balance correction, converts the color to the perceptual Lab space, and finds the best matching pH by weighted interpolation between reference pH colors. Calibration points (your brand/lighting) strongly increase accuracy. Always capture a white reference at the start of a session.</p>

        <h3 style="margin-top:12px">What you should do in the field</h3>
        <ul class="muted">
          <li>Use a neutral white light source if possible (daylight or white LED).</li>
          <li>Capture white reference (paper) once per session using the button.</li>
          <li>Hold the strip steady inside the overlay, avoid reflections and wet glare.</li>
          <li>Take 3 captures and use the Average 5 captures option if needed.</li>
        </ul>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0 0 8px 0">Calibration (recommended)</h3>
        <p class="muted">If you have a set of known pH strips (e.g., 4, 7, 10), capture each and press "Add calibration point" with the correct pH value. The app will store them in localStorage and use them for interpolation, which greatly improves accuracy under your lighting/camera/strip brand.</p>
        <div class="small muted">Stored calibration points: <span id="calList">none</span></div>
      </div>

    </section>

    <aside>
      <div class="card">
        <h3 style="margin:0 0 8px 0">Quick reference: pH ranges</h3>
        <table>
          <thead><tr><th>Range</th><th>Meaning</th></tr></thead>
          <tbody>
            <tr><td>0–3</td><td>Very acidic — hazardous</td></tr>
            <tr><td>4–6</td><td>Acidic — concern</td></tr>
            <tr><td>6.5–8.5</td><td>Healthy / neutral</td></tr>
            <tr><td>9–11</td><td>Alkaline — concern</td></tr>
            <tr><td>12–14</td><td>Very alkaline — hazardous</td></tr>
          </tbody>
        </table>
      </div>

      <div class="card" style="margin-top:12px">
        <h3 style="margin:0 0 8px 0">Developer notes</h3>
        <p class="muted">This page does not send any camera frames to servers — everything runs in the browser. Calibration lives in localStorage (only on the device).</p>
      </div>
    </aside>
  </div>

  <div style="height:28px"></div>
</main>

<footer>© 2025 Water Health & Index — Use with care. For emergencies or extreme readings, consult local authorities.</footer>

<script>
/* =========================================================
   Camera pH v3 — core logic
   - snapshot capture
   - white balance correction
   - RGB -> Lab conversion
   - color-distance + inverse-distance interpolation to estimate pH
   - robust WHI calculation with nonlinear penalties
   - calibration support stored in localStorage
   ========================================================= */

/* -------------------------
   Utilities: color conversions
   ------------------------- */
// sRGB 0..255 to linear
function srgbToLinear(v){ v/=255; return (v<=0.04045) ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }
// linear to sRGB 0..255
function linearToSrgb(v){ return (v<=0.0031308) ? 12.92*v : 1.055*Math.pow(v,1/2.4)-0.055; }

// RGB(0..255) to XYZ then to Lab (D65)
function rgbToLab({r,g,b}){
  // convert to linear RGB
  const R=srgbToLinear(r), G=srgbToLinear(g), B=srgbToLinear(b);
  // sRGB to XYZ
  // matrix
  let X = R*0.4124564 + G*0.3575761 + B*0.1804375;
  let Y = R*0.2126729 + G*0.7151522 + B*0.0721750;
  let Z = R*0.0193339 + G*0.1191920 + B*0.9503041;
  // reference white D65
  const refX=0.95047, refY=1.00000, refZ=1.08883;
  let x = X / refX, y = Y / refY, z = Z / refZ;
  function f(t){ return t>0.008856 ? Math.cbrt(t) : (7.787*t + 16/116); }
  const fx = f(x), fy = f(y), fz = f(z);
  const L = (116*fy - 16);
  const a = 500*(fx - fy);
  const bb = 200*(fy - fz);
  return {L,a,b:bb};
}

// Euclidean distance in Lab
function deltaE(lab1, lab2){
  const dL = lab1.L - lab2.L;
  const da = lab1.a - lab2.a;
  const db = lab1.b - lab2.b;
  return Math.sqrt(dL*dL + da*da + db*db);
}

/* -------------------------
   Reference pH color map (approximate)
   These RGB values are approximate typical indicator strip colors.
   You should calibrate with your strip brand for best accuracy.
   ------------------------- */
const REFERENCE_COLORS = [
  {ph:0.0, rgb:{r:139,g:0,b:0}},     // very red
  {ph:1.0, rgb:{r:180,g:24,b:20}},
  {ph:2.0, rgb:{r:214,g:70,b:27}},
  {ph:3.0, rgb:{r:244,g:123,b:36}},
  {ph:4.0, rgb:{r:253,g:188,b:48}},
  {ph:5.0, rgb:{r:252,g:233,b:85}},
  {ph:6.0, rgb:{r:220,g:245,b:140}},
  {ph:6.5, rgb:{r:196,g:250,b:170}},
  {ph:7.0, rgb:{r:120,g:200,b:120}},  // neutral green
  {ph:7.5, rgb:{r:100,g:210,b:150}},
  {ph:8.0, rgb:{r:120,g:200,b:220}},
  {ph:9.0, rgb:{r:90,g:160,b:235}},
  {ph:10.0, rgb:{r:70,g:120,b:210}},
  {ph:11.0, rgb:{r:40,g:80,b:180}},
  {ph:12.0, rgb:{r:30,g:50,b:140}},
  {ph:13.0, rgb:{r:20,g:30,b:90}},
  {ph:14.0, rgb:{r:12,g:18,b:60}}
].map(p=>{
  p.lab = rgbToLab(p.rgb);
  return p;
});

/* -------------------------
   calibration store (localStorage)
   ------------------------- */
const CAL_KEY='wh_cal_v2';
function loadCalibration(){
  try{
    const j = localStorage.getItem(CAL_KEY);
    if(!j) return [];
    const arr = JSON.parse(j);
    arr.forEach(a=>{
      a.lab = rgbToLab(a.rgb);
    });
    return arr;
  }catch(e){ return []; }
}
function saveCalibration(arr){
  localStorage.setItem(CAL_KEY, JSON.stringify(arr));
}
let calibration = loadCalibration();
updateCalUI();

function updateCalUI(){
  document.getElementById('calCount').textContent = calibration.length;
  document.getElementById('calList').textContent = calibration.length ? calibration.map(c=>c.ph).join(', ') : 'none';
}

/* -------------------------
   camera handling
   ------------------------- */
const video = document.getElementById('video');
const snapCanvas = document.getElementById('snapCanvas');
const workCanvas = document.getElementById('workCanvas');
const ctxSnap = snapCanvas.getContext('2d');
const ctxWork = workCanvas.getContext('2d');

let stream = null;
let whiteRef = null; // {r,g,b} white reference for WB
let lastCaptureRGB = null;
let lastCaptureLab = null;
let lastConfidence = 0;

// open camera
async function openCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}}, audio:false});
    video.srcObject = stream;
    document.getElementById('cameraArea').style.display='block';
    document.getElementById('captureBtn').disabled=false;
    document.getElementById('avgCaptureBtn').disabled=false;
    document.getElementById('whiteBtn').disabled=false;
    document.getElementById('addCalBtn').disabled=false;
    document.getElementById('resetCalBtn').disabled=false;
    document.getElementById('closeCamBtn').style.display='inline-block';
    document.getElementById('openCamBtn').style.display='none';
  }catch(e){
    alert('Camera access error: ' + (e.message || e));
  }
}

function closeCamera(){
  if(stream){
    stream.getTracks().forEach(t=>t.stop());
    stream=null;
  }
  video.srcObject = null;
  document.getElementById('cameraArea').style.display='none';
  document.getElementById('captureBtn').disabled=true;
  document.getElementById('avgCaptureBtn').disabled=true;
  document.getElementById('whiteBtn').disabled=true;
  document.getElementById('addCalBtn').disabled=true;
  document.getElementById('resetCalBtn').disabled=true;
  document.getElementById('closeCamBtn').style.display='none';
  document.getElementById('openCamBtn').style.display='inline-block';
}

/* capture center region average RGB */
function captureCenterRGB(boxW=120, boxH=48){
  const vW = video.videoWidth, vH=video.videoHeight;
  if(!vW || !vH) return null;
  // draw into work canvas at smaller size for speed
  workCanvas.width = vW; workCanvas.height = vH;
  ctxWork.drawImage(video, 0, 0, vW, vH);
  const cx = Math.floor(vW/2 - boxW/2), cy = Math.floor(vH/2 - boxH/2);
  try{
    const img = ctxWork.getImageData(cx, cy, boxW, boxH).data;
    let r=0,g=0,b=0,cnt=0;
    for(let i=0;i<img.length;i+=4){
      r += img[i]; g += img[i+1]; b += img[i+2]; cnt++;
    }
    const avg = {r:Math.round(r/cnt), g:Math.round(g/cnt), b:Math.round(b/cnt)};
    return avg;
  }catch(e){
    console.warn('capture error', e);
    return null;
  }
}

/* apply white-balance: simple scale factor per channel */
function applyWhiteBalance(rgb, white){
  if(!white) return rgb;
  // compute scale to bring white to neutral 255,255,255
  // avoid division by zero
  const sr = white.r||1, sg = white.g||1, sb = white.b||1;
  const kr = 255/sr, kg = 255/sg, kb = 255/sb;
  // apply and clamp
  const r = Math.round(Math.min(255, rgb.r * kr));
  const g = Math.round(Math.min(255, rgb.g * kg));
  const b = Math.round(Math.min(255, rgb.b * kb));
  return {r,g,b};
}

/* estimate pH from RGB using reference map + calibration */
function estimatePHFromRGB(rgb){
  // apply white-balance if available
  const balanced = applyWhiteBalance(rgb, whiteRef);
  const lab = rgbToLab(balanced);

  // Build a search set: combine calibration points + reference colors
  const candidates = [];
  // calibration has exact ph & lab
  calibration.forEach(c => candidates.push({ph:c.ph, lab:c.lab, from:'cal'}));
  // include reference colors
  REFERENCE_COLORS.forEach(r => candidates.push({ph:r.ph, lab:r.lab, from:'ref'}));

  // Compute deltaE to each and sort
  const withD = candidates.map(c => ({...c, d: deltaE(lab, c.lab)}));
  withD.sort((a,b)=>a.d-b.d);

  // If the best match is very close, return it directly (high confidence)
  const best = withD[0];
  const second = withD[1] || best;
  // weighted inverse distance interpolation between top N (use top 4)
  const topN = withD.slice(0,4);
  let wsum = 0, phsum=0;
  topN.forEach(item=>{
    const weight = 1 / (item.d + 1e-6); // avoid zero division
    phsum += item.ph * weight;
    wsum += weight;
  });
  const phEst = phsum / (wsum || 1);
  // Confidence: based on how small best.d is relative to typical deltaE threshold
  // deltaE < 2 is imperceptible, <6 is small, >20 is large mismatch
  const conf = Math.max(0, Math.min(1, (30 - best.d) / 30)); // scale 0..1
  return {ph: clampNumber(phEst,0,14), confidence: conf, balancedRGB: balanced, lab};
}

/* clamp helper */
function clampNumber(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* -------------------------
   WHI Calculation
   - phScore: ideal 6.5-8.5 -> 100; nonlinear decay outside
   - tempScore: ideal 22-28 -> 100
   - turbScore: low/medium/high mapping
   Combined:
   WHI = 0.4*ph + 0.3*temp + 0.3*turb
   Then small penalty for any subscore below thresholds
   ------------------------- */
function scorePH(ph){
  if(isNaN(ph)) return 50;
  // piecewise: within 6.5-8.5 -> 100
  if(ph >= 6.5 && ph <= 8.5) return 100;
  // outside range, use exponential penalty by distance
  const d = Math.min(Math.abs(ph - 6.5), Math.abs(ph - 8.5));
  // scale so that at d=1.5 -> ~70, d=3 -> ~40, d=6 -> ~5
  const score = Math.round(100 * Math.exp(-0.35 * d * d));
  return clampNumber(score, 0, 100);
}
function scoreTemp(t){
  if(isNaN(t)) return 80;
  if(t >= 22 && t <= 28) return 100;
  const d = Math.abs(t < 22 ? 22 - t : t - 28);
  // small penalty per degree
  const score = Math.round(100 * Math.exp(-0.06 * d * d));
  return clampNumber(score, 0, 100);
}
function scoreTurb(turb){
  if(!turb) return 60; // unknown
  if(turb==='low') return 100;
  if(turb==='medium') return 60;
  if(turb==='high') return 20;
  return 50;
}
function computeWHI(ph, temp, turb){
  const sPH = scorePH(ph);
  const sT = scoreTemp(temp);
  const sU = scoreTurb(turb);
  let raw = sPH*0.4 + sT*0.3 + sU*0.3;
  // extra penalty if any subscores are critically low
  const minSub = Math.min(sPH, sT, sU);
  if(minSub < 30) raw -= (30 - minSub) * 0.8;
  raw = Math.round(clampNumber(raw,0,100));
  return {index: raw, subs:{ph:sPH, temp:sT, turb:sU}};
}

/* -------------------------
   Advice bank (>=30 messages)
   ------------------------- */
const ADVICE_MESSAGES = [
  {min:97, max:100, text:'Pristine — exemplary water. Maintain buffers and monitor seasonally.'},
  {min:93, max:96, text:'Outstanding water. No action needed; log this as baseline.'},
  {min:88, max:92, text:'Very healthy. Minor seasonal checks recommended.'},
  {min:82, max:87, text:'Excellent — suitable for recreation and ecological health.'},
  {min:76, max:81, text:'Good — maintain riparian vegetation; avoid nearby pollutants.'},
  {min:70, max:75, text:'Fair-good — reduce runoff; consider filtration for drinking.'},
  {min:64, max:69, text:'Fair — monitor nutrients and turbidity; inspect upstream.'},
  {min:58, max:63, text:'Moderate — investigate possible point sources of pollution.'},
  {min:52, max:57, text:'Borderline — avoid drinking; basic filtration recommended.'},
  {min:46, max:51, text:'Below desirable — lab testing advised for metals and organics.'},
  {min:40, max:45, text:'Degraded — passive neutralization and source control required.'},
  {min:34, max:39, text:'Poor — avoid contact; implement buffer restoration.'},
  {min:28, max:33, text:'Very poor — possible chemical contamination; stop use for sensitive tasks.'},
  {min:22, max:27, text:'Critical — collect samples, notify authorities, and prevent access.'},
  {min:16, max:21, text:'Severe — urgent remediation and lab investigation needed.'},
  {min:10, max:15, text:'Extreme — hazardous to aquatic life; restrict access and escalate.'},
  {min:5, max:9, text:'Catastrophic — specialist cleanup likely required. Avoid contact.'},
  {min:0, max:4, text:'Dead zone — severe contamination. Immediate professional action required.'},
  // extra granular messages for more nuance
  {min:90, max:92, text:'Very healthy — minimal human impact.'},
  {min:85, max:89, text:'Healthy but monitor after heavy rain.'},
  {min:80, max:84, text:'Good — small seasonal impacts possible.'},
  {min:75, max:79, text:'Slight downgrade — watch for sediment increase.'},
  {min:65, max:74, text:'Moderate stress; implement riparian plantings.'},
  {min:55, max:64, text:'Noticeable issues — conduct nutrient tests.'},
  {min:45, max:54, text:'Contamination likely; reduce point source inputs.'},
  {min:35, max:44, text:'High turbidity or pH issues — lab testing recommended.'},
  {min:25, max:34, text:'Significant problem — restrict usage and inform community.'},
  {min:15, max:24, text:'Dangerous — immediate action needed.'},
  {min:1, max:14, text:'Acute hazard — do not use; report to authorities.'}
];

function adviceForIndex(idx){
  for(const a of ADVICE_MESSAGES){
    if(idx >= a.min && idx <= a.max) return a.text;
  }
  return 'No specific advice found.';
}

/* -------------------------
   UI wiring
   ------------------------- */
const openCamBtn = document.getElementById('openCamBtn');
const captureBtn = document.getElementById('captureBtn');
const avgCaptureBtn = document.getElementById('avgCaptureBtn');
const whiteBtn = document.getElementById('whiteBtn');
const closeCamBtn = document.getElementById('closeCamBtn');
const addCalBtn = document.getElementById('addCalBtn');
const resetCalBtn = document.getElementById('resetCalBtn');
const calStatus = document.getElementById('calStatus');

const manualPH = document.getElementById('manualPH');
const tempInput = document.getElementById('tempInput');
const turbiditySelect = document.getElementById('turbiditySelect');
const analyzeBtn = document.getElementById('analyzeBtn');
const saveBtn = document.getElementById('saveBtn');

const captureInfo = document.getElementById('captureInfo');

const resultBlock = document.getElementById('resultBlock');
const scoreBubble = document.getElementById('scoreBubble');
const indexVal = document.getElementById('indexVal');
const indexText = document.getElementById('indexText');
const detectedPH = document.getElementById('detectedPH');
const adviceShort = document.getElementById('adviceShort');
const confVal = document.getElementById('confVal');
const subscoresEl = document.getElementById('subscores');
const rgbVal = document.getElementById('rgbVal');
const isCalibratedEl = document.getElementById('isCalibrated');
const safetyWarn = document.getElementById('safetyWarn');

openCamBtn.addEventListener('click', openCamera);
closeCamBtn.addEventListener('click', closeCamera);

/* capture single */
captureBtn.addEventListener('click', ()=>{
  const avg = captureCenterRGB();
  if(!avg){ alert('Camera not ready.'); return; }
  // if whiteRef exists, apply
  const balanced = applyWhiteBalance(avg, whiteRef);
  const est = estimatePHFromRGB(avg);
  lastCaptureRGB = est.balancedRGB;
  lastCaptureLab = est.lab;
  lastConfidence = est.confidence;
  captureInfo.textContent = `Captured RGB: R${lastCaptureRGB.r} G${lastCaptureRGB.g} B${lastCaptureRGB.b} · est pH ${est.ph.toFixed(2)} · conf ${(est.confidence*100).toFixed(0)}%`;
  // show in UI but don't analyze until user clicks Analyze or auto-run
  displayCaptureResult(est);
});

/* average 5 captures */
avgCaptureBtn.addEventListener('click', async ()=>{
  if(!stream){ alert('Open camera first'); return; }
  const samples = [];
  for(let i=0;i<5;i++){
    await new Promise(r=>setTimeout(r, 350));
    const s = captureCenterRGB();
    if(s) samples.push(s);
  }
  if(!samples.length){ alert('No samples'); return; }
  // average samples
  const avg = samples.reduce((acc,cur)=>({r:acc.r+cur.r,g:acc.g+cur.g,b:acc.b+cur.b}), {r:0,g:0,b:0});
  avg.r = Math.round(avg.r/samples.length); avg.g = Math.round(avg.g/samples.length); avg.b = Math.round(avg.b/samples.length);
  const balanced = applyWhiteBalance(avg, whiteRef);
  const est = estimatePHFromRGB(avg);
  lastCaptureRGB = est.balancedRGB;
  lastCaptureLab = est.lab;
  lastConfidence = est.confidence;
  captureInfo.textContent = `Avg capture (${samples.length}) R${lastCaptureRGB.r} G${lastCaptureRGB.g} B${lastCaptureRGB.b} · est pH ${est.ph.toFixed(2)} · conf ${(est.confidence*100).toFixed(0)}%`;
  displayCaptureResult(est);
});

/* white capture for white-balance */
whiteBtn.addEventListener('click', ()=>{
  const w = captureCenterRGB(200,200); // larger box for white
  if(!w){ alert('Camera not ready'); return; }
  whiteRef = w;
  document.getElementById('captureInfo').textContent = `White reference captured: R${w.r} G${w.g} B${w.b}`;
});

/* calibration: add point */
addCalBtn.addEventListener('click', ()=>{
  // require manual entry of pH to tie to current capture
  if(!lastCaptureRGB){ alert('Capture a strip first'); return; }
  const ph = prompt('Enter the exact pH value for this captured color (e.g., 7.00):');
  if(!ph) return;
  const phv = parseFloat(ph);
  if(isNaN(phv) || phv < 0 || phv > 14){ alert('Invalid pH'); return; }
  // store calibration using the balanced RGB and computed lab
  const entry = {ph:phv, rgb:lastCaptureRGB};
  entry.lab = rgbToLab(entry.rgb);
  calibration.push(entry);
  saveCalibration(calibration);
  updateCalUI();
  alert('Calibration point added. Total: ' + calibration.length);
});

/* reset calibration */
resetCalBtn.addEventListener('click', ()=>{
  if(!confirm('Reset calibration points?')) return;
  calibration = [];
  saveCalibration(calibration);
  updateCalUI();
});

/* Estimate + analyze (button) */
analyzeBtn.addEventListener('click', ()=>{
  // choose pH: manual override > last capture
  let ph = null; let conf = 0;
  if(manualPH.value){
    ph = parseFloat(manualPH.value);
    conf = 1.0;
  } else if(lastCaptureLab){
    const est = estimatePHFromRGB(lastCaptureRGB); // re-estimate to be safe
    ph = est.ph;
    conf = est.confidence;
  } else {
    alert('No pH available: either enter manually or capture via camera.');
    return;
  }
  const temp = parseFloat(tempInput.value) || NaN;
  const turb = turbiditySelect.value || null;
  // compute WHI
  const whi = computeWHI(ph, temp, turb);
  // UI:
  resultBlock.classList.remove('hidden');
  indexVal.textContent = `${whi.index} / 100`;
  indexText.textContent = whi.index >= 80 ? 'GOOD' : (whi.index >= 50 ? 'MODERATE' : 'POOR');
  detectedPH.textContent = ph.toFixed(2);
  adviceShort.textContent = adviceForIndex(whi.index);
  confVal.textContent = (conf*100).toFixed(0) + '%';
  subscoresEl.textContent = `pH score: ${whi.subs.ph} • Temp score: ${whi.subs.temp} • Turbidity score: ${whi.subs.turb}`;
  rgbVal.textContent = lastCaptureRGB ? `R${lastCaptureRGB.r} G${lastCaptureRGB.g} B${lastCaptureRGB.b}` : '—';
  isCalibratedEl.textContent = calibration.length ? 'yes' : 'no';
  // bubble color
  if(whi.index >= 80){ scoreBubble.className = 'bubble status-good'; }
  else if(whi.index >= 50){ scoreBubble.className = 'bubble status-warn'; }
  else { scoreBubble.className = 'bubble status-bad'; }
  scoreBubble.textContent = whi.index;
  // safety warnings
  if(conf < 0.45 || ph < 4 || ph > 11 || whi.index < 40){
    safetyWarn.classList.remove('hidden');
    let warns = [];
    if(conf < 0.45) warns.push('Low confidence: retake capture under neutral lighting and capture white reference.');
    if(ph < 4) warns.push('Extremely acidic reading — avoid contact and seek lab confirmation.');
    if(ph > 11) warns.push('Extremely alkaline reading — avoid contact and seek lab confirmation.');
    if(whi.index < 40) warns.push('Low Water Health Index — consider lab testing and notifying authorities.');
    safetyWarn.innerHTML = warns.join('<br>');
  } else safetyWarn.classList.add('hidden');

  // enable save button only if confidence && location or user is okay
  document.getElementById('saveBtn').disabled = false;
});

/* display capture result helper */
function displayCaptureResult(est){
  // quick preview in UI: detected PH field updated, confidence show
  document.getElementById('detectedPH').textContent = est.ph.toFixed(2);
  document.getElementById('confVal').textContent = Math.round(est.confidence*100) + '%';
  document.getElementById('rgbVal').textContent = `R${est.balancedRGB.r} G${est.balancedRGB.g} B${est.balancedRGB.b}`;
}

/* Save reading (localStorage only) — minimal */
const LS_READ = 'wh_readings_v2';
function loadReadings(){ try { return JSON.parse(localStorage.getItem(LS_READ) || '[]'); }catch(e){return [];} }
function saveReadingObj(obj){
  const arr = loadReadings(); arr.unshift(obj); localStorage.setItem(LS_READ, JSON.stringify(arr));
  alert('Reading saved locally.');
}

document.getElementById('saveBtn').addEventListener('click', ()=>{
  let ph = manualPH.value ? parseFloat(manualPH.value) : (lastCaptureLab ? estimatePHFromRGB(lastCaptureRGB).ph : null);
  if(ph===null || isNaN(ph)){ alert('No pH ready to save'); return; }
  const temp = parseFloat(tempInput.value) || null;
  const turb = turbiditySelect.value || null;
  const whi = computeWHI(ph, temp, turb);
  const now = new Date().toISOString();
  const entry = {ts:now, ph:ph, temp:temp, turb:turb, index:whi.index, rgb:lastCaptureRGB, conf:lastConfidence};
  saveReadingObj(entry);
});

/* -------------------------
   On load: wire buttons
   ------------------------- */
document.getElementById('openCamBtn').addEventListener('click', openCamera);
document.getElementById('closeCamBtn').addEventListener('click', closeCamera);

/* optional: read ?ph= prefill */
(function prefillFromQuery(){
  try{
    const p = new URLSearchParams(window.location.search).get('ph');
    if(p){ document.getElementById('manualPH').value = parseFloat(p); }
  }catch(e){}
})();

/* helper: ensure camera buttons disabled when not supported */
if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
  document.getElementById('openCamBtn').disabled = true;
  captureInfo.textContent = 'Camera not supported in this browser.';
}

/* End of script */
</script>

</body>
</html>
